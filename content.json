{"pages":[{"title":"简历","text":"个人信息姓名：李超生日：1993-04-13籍贯：湖南-郴州学校：中国计量学院专业：机械电子工程学历：本科 联系方式手机：15658109965邮箱：relengxing@outlook.comQQ：670656469微信：15658109965 我的技能 精通 Java，熟悉 SpringBoot、Mybatis 等开发框架熟悉微服务，熟悉 SpringCloud 熟悉 Python，熟悉 Pandas，主要是数据处理方向 熟悉 JS、HTML、CSS、jQuery、Bootstrap 等前端知识 熟悉 MySQL，Redis，Mongodb，RabbitMQ 熟悉 Linux能完成生产环境搭建及服务器运维 熟悉 Docker、Kubernetes经历公司容器化发展，能进行容器化开发和运维 熟悉云服务Azure：熟悉 Databricks（Spark）、DataLake(Hdfs)等工具Google Cloud：DataProc（Spark）、BigQuery(Hdfs)等工具经历公司从 Azure 迁移到 Google Cloud 熟悉 C 语言和 Go 语言 工作经验 公司：贝深科技（深圳）有限公司职务：Java 开发工程师时间： 2017.02-至今公司的主营业务是为零售商提供软件服务，是一家外企，客户都在美国，服务器都在 Azure 和 Google Cloud 上。加入公司的时候是公司人员大换血时，第一年只有我一个 Java 后端。第一年工作是 Java 开发，工作内容包括修复线上 Bug，开发新需求，服务器运维。开发了一个新项目的后端，项目是基于 SpringBoot 开发的，用于管理客户信息和设备信息。第二年开始主要是新版本的开发，项目是基于 SpringCloud 开发的。后来公司转型，应用端开始放弃维护，开始转到 Python 开发，主要是数据处理方向。技术栈包括 Python、Pandas、云平台的 Spark 及 Hadoop 等。期间对 Kubernetes 研究较多，完成了公司项目容器化，统一了数据处理流程，开发了一个 Kubernetes 任务发布系统。 公司：杭州能联科技有限公司职务：嵌入式软件开发工程师时间： 2014.12-2016.08公司的主营业务是智能水表和远程集抄。在公司期间完成了多个项目和模块开发，如 GPRS 单表主动上报式采集器，无磁水表，蓝牙转串口模块等，能快速学习使用一个新的单片机，能自己研究手册独立进行开发。 教育背景 学校：中国计量学院 专业：机械电子工程 时间：2011.09 - 2015.06 学历：本科 个人介绍 五年软件开发经验，三年 Java 开发经验，基础扎实，涉猎广泛。 学习能力强，能快速上手新技术，具备主动学习精神。 思路清晰，具有良好的方案设计能力，解决问题能力强。 沟通能力强，具有良好的团队合作精神。 社交主页 博客：https://relengxing.github.io/ Github：https://github.com/relengxing 简书：http://www.jianshu.com/u/d7acd6530ab6 项目经验 项目名称: ETL pipeline时间：2019.01 – 2019.10负责内容：Python 软件开发项目介绍：此项目包含多个模块，流程是：客户上传文件到 FTP 服务器或者 Google Drive,触发器会根据配置扫描 FTP 服务器和 Google Drive，如果有符合规则的文件则进过简单的处理后上传到 Google Storage,并触发 Data Proc 任务，Data Proc 会对数据去重并写入 Big Query，然后预处理模块会对数据进行处理，检查出异常数据和缺失数据，并对数据进行修复，写入到 Big Query 中，这部分数据会供预测算法使用，最后还会提取数据，写入到数据仓库中，方便报告使用。 项目名称：Kuberobot时间：2018.11 – 2018.12负责内容：Java 软件开发项目介绍：此项目是一个 Kubernetes 任务发布系统，公司的任务统一发布到 redis，kuberobot 会根据任务优先级把任务发布到 kubernetes，并发送运行结果到 Slack 上，会根据任务队列的长度对 Kubernetes 进行扩缩容，支持自动扩容和手动扩容。 项目名称：Admin portal时间：2017.08 – 2019.09负责内容：Java 软件开发项目介绍：此项目是一个对客户店铺和设备进行管理的项目，提供数据展示（例如：设备存活率，历史 data hole 等），设备配置，数据导入等功能，后端使用的是 SpringBoot，前端使用的是 JQuery，Bootstrap。 项目名称：Staffum时间：2017.02 – 2018.10负责内容：Java 软件开发项目介绍：此项目是我加入 Percolata 接手的项目，主要是对零售商的数据进行管理（店铺数据，员工数据，销售数据，人流量数据），提供数据展示，排班（手动排班和自动排班），请假等功能。我负责的是整个项目的维护，新需求开发，新版本开发。第一个版本后端使用 Springboot,管理员前端使用的是 angular，员工前端使用的是 React Native，第二个版本后端使用的是 SpringCloud，前端使用的是 ionic。 项目名称：模拟采集器和主站时间：2017.01 – 2017.01负责内容：JAVA 软件开发，Golang 软件开发项目介绍：此项目分为两部分：集中器部分和主站部分。集中器是使用 Golang 开发的模拟集中器，可以使用网页对模拟集中器进行管理，程序会定启动，上报数据到主站。主站是使用 JAVA 开发的服务器，可以使用网页对表记信息和表记数据进行管理。 项目名称：单表主动上报式采集器时间：2015.12 – 2016.02负责内容：单片机软件开发项目介绍：此项目是使用 EFM32TG840 单片机对水表进行数据采集。定期通过 GPRS M6310 模块与主站通讯，上报抄表数据，参数可以通过主站或者本地操控器进行设置。 项目名称：无磁水表时间：2015.03 – 2015.06负责内容：单片机软件开发，上位机软件开发（C#）项目介绍：此项目是基于 msp430fw427 单片机开发的。该项目主要是通过 ScanIF 模块和 LC 振荡电路来对水表转子的转动进行计数。并可以通过上位机的小软件对单片机进行数据采集和阀门控制。上位机的软件是用 C#开发的 项目名称：蓝牙转串口模块时间：2015.01 – 2015.01负责内容：单片机软件开发项目介绍：此项目是基于 SCH16L 单片机和 HC-06 蓝牙模块开发的。单片机通过一个串口和蓝牙模块进行通讯，另一个串口连接表记。可以通过给蓝牙发送数据和另一端的表记进行通讯。单片机可以识别是数据还是命令码，命令码可以对波特率等参数进行修改。 项目名称：爬壁机器人时间：2013.10 – 2014.05负责内容：Solidworks 三维制图，电机驱动开发项目介绍：这是一个大学时做的项目，是可以在垂直墙面上运动的机器人，该项目还参与了挑战杯，获得挑战杯校一等奖。我是机械部分的负责人，负责机械部分设计，三维制图，并参与了电机驱动部分的软件开发。","link":"/cv/index.html"},{"title":"about","text":"找工作 ing","link":"/about/index.html"}],"posts":[{"title":"ReBus","text":"说明ReBus 是一个模仿 RxBus 写的，基于 reactor3 的事件总线 RxBus 一般是 Android 端使用的，ReBus 一般是后端使用的RxBus 参考链接： https://github.com/relengxing/RxBusReBus 源码链接： https://github.com/relengxing/ReBus 推荐直接看 RxBus 的解析，这边只贴代码，因为思想是一模一样的，只是底层的包不一样，封装完后用法也是一样的。 源码解析ReBus 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.relenxing.config;import com.relenxing.domain.Event;import reactor.core.publisher.Flux;import reactor.core.publisher.ReplayProcessor;public class ReBus { /** * 事件总线的核心。 */ private final ReplayProcessor&lt;Event&gt; bus; /** * 构造函数，初始化 */ private ReBus() { bus = ReplayProcessor.create(); } /** * 单例模式 */ public static ReBus getDefault() { return HelperHolder.instance; } /** * 延迟初始化，这里是利用了 Java 的语言特性，内部类只有在使用的时候，才会去加载， * 从而初始化内部静态变量。关于线程安全，这是 Java 运行环境自动给你保证的， * 在加载的时候，会自动隐形的同步。在访问对象的时候， * 不需要同步 Java 虚拟机又会自动给你取消同步，所以效率非常高。 */ private static class HelperHolder { static final ReBus instance = new ReBus(); } /** * 发送普通事件 */ public void post(Event event){ bus.onNext(event); } public Flux&lt;Event&gt; on(String type){ return bus.filter(e -&gt; e.getEventName().equals(type)); }} Event 代码： 12345678910111213141516171819202122232425262728293031323334353637package com.relenxing.domain;import java.io.Serializable;public class Event&lt;T&gt; implements Serializable { private static final long serialVersionUID = 1L; private String eventName; private T event; public Event() { } public Event(String eventName, T event) { this.eventName = eventName; this.event = event; } public String getEventName() { return eventName; } public void setEventName(String eventName) { this.eventName = eventName; } public T getEvent() { return event; } public void setEvent(T event) { this.event = event; }} demo 1234567891011121314package com.relenxing;public class Main { public static void main(String[] args) { ReBus.getDefault().post(new Event&lt;&gt;(\"123\", \"123\")); ReBus.getDefault().post(new Event&lt;&gt;(\"456\", \"swdw\")); ReBus.getDefault().post(new Event&lt;&gt;(\"123\", \"312\")); ReBus.getDefault().post(new Event&lt;&gt;(\"456\", \"2f2\")); ReBus.getDefault().post(new Event&lt;&gt;(\"123\", \"12f\")); ReBus.getDefault().on(\"123\").map(Event::getEvent).subscribe(System.out::println); ReBus.getDefault().on(\"456\").map(Event::getEvent).subscribe(System.out::println); }}","link":"/2017/09/08/ReBus/"},{"title":"RxBus","text":"参考：用 RxJava 实现事件总线(Event Bus)http://www.jianshu.com/p/ca090f6e2fe2 我这篇基本上就是按照上面那篇写的，对 Sticky 那一块进行了一些修改。写下来让自己记得更深刻。这篇文章面向有 RxJava 基础的人，要是 HelloWorld 都没写过建议先看基础部分。 Git 地址：https://github.com/relengxing/RxBus 步骤 新建工程 添加 rxjava 和 rxandroid 依赖 完成以下界面 编写 RxBus 文件 编写其他代码 RxBus 是一个全局使用的总线，应该使用单例模式。单例模式的具体写法可以自己研究下。参考代码：http://www.race604.com/java-double-checked-singleton/ 1234567891011121314/*** Created by relengxing on 2016/8/12.*/public class RxBus { private RxBus() { } public static RxBus getDefault() { return HelperHolder.instance; } private static class HelperHolder { public static final RxBus instance = new RxBus(); }} 事件总线那么需要一根总线来传输数据。这根总线就是 RxJava 中的 Subject。 Subject 可以看成是一个桥梁或者代理，在某些 ReactiveX 实现中（ 如 RxJava） ，它同时充当了 Observer 和 Observable 的角色。因为它是一个 Observer，它可以订阅一个或多个 Observable；又因为它是一个 Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。 在 RxJava 中针对不同的场景一共有四种类型的 Subject。 AsyncSubject BehaviorSubject PublishSubject ReplaySubject关于这四种类型的具体说明参考：RxJava：Subject 介绍 这里使用的是 PublishSubjectPublishSubject：只会把在订阅发生的时间点之后来自原始 Observable 的数据发射给观察者；又因为线程安全的问题，需要把 PublishSubject 转化为一个线程安全的 Subject，这部分内容也在RxJava：Subject 介绍最后一部分串行化中有介绍。最后代码写成如下： private final Subject&lt;Object,Object&gt; bus; private RxBus() { bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); }总线有了，还差事件发布者（被观察者）和事件接受者（观察者）。 发送事件将事件 post 至 Subject，此时 Subject 作为 Observer 接收到事件（onNext），然后会发射给所有订阅该 Subject 的订阅者。因为使用的是 PublishSubject，所以必须先订阅事件再发送事件才能介绍到，否则这些发送的事件会遗失。 123public void post(Object object){ bus.onNext(object);} 接收事件123public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType){ return bus.ofType(eventType);} ofType 是 filter 操作符的一个特殊形式。它过滤一个 Observable 只返回指定类型的数据。ofType 默认不在任何特定的调度器上指定 。 有一点需要注意的是，在接收事件的地方不需要接收事件或者生命周期结束的时候一定要取消订阅，防止内存泄漏。 123if (!rxSubscription2.isUnsubscribed()) { rxSubscription2.unsubscribe();} 支持 Sticky 事件 在 Android 开发中，Sticky 事件只指事件消费者在事件发布之后才注册的也能接收到该事件的特殊类型。Android 中就有这样的实例，也就是 Sticky Broadcast，即粘性广播。正常情况下如果发送者发送了某个广播，而接收者在这个广播发送后才注册自己的 Receiver，这时接收者便无法接收到刚才的广播，为此 Android 引入了 StickyBroadcast，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完 Receiver 后就可以接收到刚才已经发布的广播。这就使得我们可以预先处理一些事件，让有消费者时再把这些事件投递给消费者。 参考：深入 RxBus：［支持 Sticky 事件］ 关于方案选择不再详述了，参考上面的链接。同样使用的是 ConcurrentHashMap参考资料中使用的是 1private final Map&lt;Class&lt;?&gt;, Object&gt; mStickyEventMap; 那么同一个类只会有一个对象保留，后面发送的对象会把前面的对象覆盖掉。而我希望一个新的对象不会覆盖老的对象，需要自己手动来删除。所以这个地方改成 1private final ConcurrentHashMap&lt;Class&lt;?&gt;,List&lt;Object&gt;&gt; map; Sticky 事件和普通事件使用的是同一个 Bus,所以接收者接收的是同一个对象时，当他们都订阅了事件时是没有区别的。 发送 Sticky 事件这个其实就是在发送普通时间之前把这个事件写入到刚刚的 map 中去。 1234567891011public void postSticky(Object object){ synchronized (mStickyEventMap){ List list = mStickyEventMap.get(object.getClass()); if (list == null) { list = new ArrayList(); } list.add(object); mStickyEventMap.put(object.getClass(),list); } post(object);} 接收 Sticky 事件这个就是先查看 map 中是否有这个事件，有的话使用.merginWith 一起发出来。 123456789101112131415161718public &lt;T&gt; Observable&lt;T&gt; toObservableSticky(final Class&lt;T&gt; eventType){ synchronized (mStickyEventMap){ Observable&lt;T&gt; observable = bus.ofType(eventType); final List list = mStickyEventMap.get(eventType); if (list != null &amp;&amp; !list.isEmpty()) { return observable.mergeWith(Observable.create(new Observable.OnSubscribe&lt;T&gt;(){ @Override public void call(Subscriber&lt;? super T&gt; subscriber) { for (Object obj :list) { subscriber.onNext(eventType.cast(obj)); } } })); }else { return observable; } }} 还写了一些常用方法，例如 post 一个事件的时候覆盖同类事件，接收事件时消耗掉事件，代码在简书上写起来还是有点麻烦，详情看 GitHub，地址：https://github.com/relengxing/RxBus要使用的时候把 RxBus 文件直接复制到工程即可。如果有 BUG 可以在评论区告诉我。","link":"/2016/08/13/RxBus/"},{"title":"树莓派3搭建linux服务器","text":"前段时间租了三个月阿里云，感觉太贵了，就买了个树莓派 3，准备搭建一个 linux 操作系统，当服务器用用，大概花费不到 300。电源 5V×2.5A，一般情况下不用这么高的电流，功耗其实很低的。 组装就不说了。。成品如下几个要下载的东西:链接：http://pan.baidu.com/s/1o8FC0xO 密码：psww这个是系统把他解压出来是一个.img 文件。 这个软件安装一下。Win32DiskImager-0.9.5-install.exe内存卡，读卡器准备好 然后就写到系统里面 写完以后就可以插到树莓派上了，网线端接路由器的 LAN 口，电脑和树莓派在同一个局域网下。上电，等开好机 在路由器管理页面下可以找到我的是 192.168.0.104 然后就可以用 xshell 连接了然后就登录成功了我这里是用有线连接的，无线的没有去做了OK,大功告成，然后可以开始装各种软件的开发环境了。","link":"/2019/10/24/%E6%A0%91%E8%8E%93%E6%B4%BE3%E6%90%AD%E5%BB%BAlinux%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"rxjava","slug":"rxjava","link":"/tags/rxjava/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"categories":[]}